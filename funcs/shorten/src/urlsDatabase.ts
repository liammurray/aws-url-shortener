import AWS from 'aws-sdk'
import { logger, envStr } from './util'
import { createDynamoClient } from './awsUtil'
import { encodeBase62 } from './encode'
import { DataMapper, DynamoDbTable } from '@aws/dynamodb-data-mapper'
import { hashKey, table, attribute } from '@aws/dynamodb-data-mapper-annotations'
// import { MathematicalExpression, FunctionExpression, UpdateExpression } from '@aws/dynamodb-expressions'
import _get from 'lodash.get'
//import crypto from 'crypto'

const urlEntriesTableName = envStr('TABLE_NAME_URLS')

const MIN_ALIAS_LENGTH = 6
// Must be at least MIN_ALIAS_LENGTH
const ID_COUNTER = 'counter'
const INIT_COUNTER_VALUE = 1000

// export function createHash(str: string): string {
//   return crypto.createHash('sha256').update(str).digest('hex')
// }

/**
 * Auto-generated short names:
 *
 *  - The short name is generated by converting a monitonically incrementing counter to Base62.
 *  - This keeps auto generated names as short as possible.
 *  - The counter is stored in a special entry with id "counter" (with value stored in url field).
 *
 * Aliases:
 *
 *  - Alias itself is used as short name
 *  - Alias must be at least MIN_ALIAS_LENGTH characters
 *      - 62^5 = 916132832 slots for counter range
 *  - The min length is a trick to eliminate collisions with counter and simplify logic
 *
 * Partition key:
 *  - The partition key (id) is the short name or alias
 */
@table(urlEntriesTableName)
export class UrlEntry {
  /** Partition key */
  @hashKey()
  id!: string

  /** Time created */
  @attribute({ defaultProvider: () => new Date() })
  createdAt!: Date

  /** Last access (TODO) */
  @attribute({ defaultProvider: () => new Date() })
  lastAccess!: Date

  /** URL (or counter) */
  url!: string
}

export type CreateCode = 'created' | 'aliasExists' | 'aliasInvalid'

export type CreateResult = {
  code: CreateCode
  msg?: string
  id: string
}

/**
 * Access layer built on DynamoDb
 */
export class UrlsDatabase {
  private mapper: DataMapper
  private dbc: AWS.DynamoDB.DocumentClient
  constructor(client: AWS.DynamoDB) {
    this.mapper = new DataMapper({ client })
    this.dbc = new AWS.DynamoDB.DocumentClient({ service: client })
  }

  /**
   * Automically increments counter. The counter is stored in a special record.
   * The counter value itself is stored in the "url" field.
   */
  async getNextCounter(): Promise<number> {
    // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#update-property
    const res = await this.dbc
      .update({
        TableName: UrlEntry.prototype[DynamoDbTable],
        Key: { id: ID_COUNTER },
        UpdateExpression: 'SET #val = if_not_exists(#val, :dv) + :incr',
        ExpressionAttributeNames: { '#val': 'url' },
        ExpressionAttributeValues: { ':incr': 1, ':dv': INIT_COUNTER_VALUE },
        ReturnValues: 'UPDATED_NEW',
      })
      .promise()
    const counter = _get(res, 'Attributes.url')
    return parseInt(counter)
  }

  // Seems support for func expression as argument not supported in 0.7.3 (not published yet)
  // async getNextCounterX(): Promise<number> {
  //   const expr = new UpdateExpression()
  //   const lhs = new FunctionExpression('if_not_exists', INIT_COUNTER_VALUE)
  //   expr.set('url', new MathematicalExpression(lhs, '+', 1))
  //   const entry = await this.mapper.executeUpdateExpression(expr, { id: ID_COUNTER }, UrlEntry)
  //   return parseInt(entry.url)
  // }

  async getNextShortName(): Promise<string> {
    return encodeBase62(await this.getNextCounter())
  }

  /**
   * Creates a URL entry with a unique auto-generated short name.
   * Returns the short name.
   * Does not check if original URL is unique. You can call getByUrl() first.
   */
  async createAuto(url: string): Promise<CreateResult> {
    logger.info({ url }, 'createAuto')

    const entry = new UrlEntry()
    entry.id = await this.getNextShortName()
    entry.url = url
    logger.info({ entry }, 'Adding entry')
    await this.mapper.put(entry)
    return {
      code: 'created',
      msg: 'Generated id',
      id: entry.id,
    }
  }

  async createAlias(alias: string, url: string): Promise<CreateResult> {
    logger.info({ alias, url }, 'createAlias')

    if (alias.length < MIN_ALIAS_LENGTH) {
      return {
        code: 'aliasInvalid',
        msg: `Alias must be at least ${MIN_ALIAS_LENGTH} characters`,
        id: alias,
      }
    }

    const existing = await this.getById(alias)
    if (existing) {
      return {
        code: 'aliasExists',
        msg: `Alias already exists`,
        id: alias,
      }
    }

    const entry = new UrlEntry()
    entry.id = alias
    logger.info({ entry }, 'Adding entry')
    await this.mapper.put(entry)
    return {
      code: 'created',
      msg: 'Added alias',
      id: entry.id,
    }
  }

  /**
   * Looks up url entry by short name or alias
   */
  async getById(id: string): Promise<UrlEntry | undefined> {
    const entry = new UrlEntry()
    entry.id = id
    try {
      return await this.mapper.get(entry)
    } catch (err) {
      // ItemNotFoundException
      logger.info({ err }, 'get')
    }
  }

  async deleteById(id: string): Promise<void> {
    const entry = new UrlEntry()
    entry.id = id
    try {
      await this.mapper.delete(entry)
    } catch (err) {
      logger.info({ err }, 'delete')
    }
  }
}

let urls: UrlsDatabase

export function getUrlsDatabase(): UrlsDatabase {
  if (!urls) {
    urls = new UrlsDatabase(createDynamoClient())
  }
  return urls
}
